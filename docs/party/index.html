<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>VRM Sync Test</title>
    <style>
      body {
        margin: 0;
        background: #000;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #video {
        display: none;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/",
          "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.webgpu.js",
          "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.tsl.js",
          "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js",
          "@pixiv/three-vrm/nodes": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/nodes/index.module.js",
          "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.22-rc.20250304/+esm"
        }
      }
    </script>
    <script type="module">
      import * as vision from "@mediapipe/tasks-vision";
      import { initScene, resize, setBackgroundColor } from "./scene.js";
      import {
        loadAvatar,
        calculateBlendshapes,
        updateBlendshape,
        changeAvatar,
        destroyAvatar,
        updateAvatars,
        existsOriginalAvatar,
        getModelArrayBuffer,
        updateAvatarName,
        avatars,
      } from "./avatarManager.js";
      import { connectWebSocket } from "./wsClient.js";

      const getUserId = () => {
        let id = localStorage.getItem("userId");
        if (!id) {
          id = crypto.randomUUID();
          localStorage.setItem("userId", id);
        }
        return id;
      };

      const userId = getUserId();

      const changeName = (name) => {
        updateAvatarName(userId, name);
      };

      const { scene, clock, camera, renderer } = initScene();

      loadAvatar(userId, scene, { x: 0, y: 0, z: 0 });

      const nameInput = document.getElementById("name-input");
      const storedName = localStorage.getItem("userName") || "";
      if (storedName) {
        nameInput.value = storedName;
        updateAvatarName(userId, storedName);
      }

      // WebSocket接続
      const handlers = {
        onJoin: (msg) => {
          msg.existingUserIds.forEach(async (id) => {
            if (!avatars[id]) {
              if (storedName) sendName(userId, storedName);
              loadAvatar(id, scene, { x: 0, y: 0, z: 0 });
              if (!(await existsOriginalAvatar(id))) {
                console.log("Requesting VRM for user:", id);
                requestVrm(userId, id);
              }
            }
          });
        },
        onUserJoined: (msg) => {
          console.log("User Joined:", msg);

          if (!avatars[msg.userId]) {
            loadAvatar(msg.userId, scene, { x: 0, y: 0, z: 0 });
          }
        },
        onChangeName: (msg) => {
          updateAvatarName(msg.userId, msg.name);
        },
        onReceiveVrm: async (userId, arrayBuffer) => {
          console.log("Received VRM for user:", userId);
          await changeAvatar(userId, arrayBuffer);
        },
        onReceiveMotion: (msg) => {
          updateBlendshape(msg.userId, msg.data);
        },
        onRequestMyVrm: async (msg) => {
          sendVrm(msg);
        },
        onUserLeft: (msg) => {
          console.log("User Left:", msg.userId);
          destroyAvatar(msg.userId);
        },
      };

      const ws = connectWebSocket(userId, handlers);

      const sendVrm = async (msg) => {
        const arrayBuffer = await getModelArrayBuffer(userId);
        if (arrayBuffer) {
          ws.sendVrm(userId, arrayBuffer, msg.targetId);
        }
      };

      const sendName = (name) => {
        ws.sendName(userId, name);
      };

      const requestVrm = (requestTo) => {
        ws.requestVrm(userId, requestTo);
      };

      const video = document.getElementById("video");

      const initCamera = async () => {
        video.srcObject = await navigator.mediaDevices.getUserMedia({
          video: true,
        });
        return new Promise((r) => (video.onloadedmetadata = () => r(video)));
      };

      const startFaceTracking = async (video) => {
        const { FaceLandmarker, FilesetResolver } = vision;

        const filesetResolver = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.22-rc.20250304/wasm",
        );
        const faceLandmarker = await FaceLandmarker.createFromOptions(
          filesetResolver,
          {
            baseOptions: {
              modelAssetPath:
                "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task",
              delegate: "GPU",
            },
            outputFaceBlendshapes: true,
            outputFacialTransformationMatrixes: true,
            numFaces: 1,
            runningMode: "VIDEO",
          },
        );

        const detect = async () => {
          const result = await faceLandmarker.detectForVideo(
            video,
            performance.now(),
          );
          if (result.faceLandmarks?.length > 0) {
            const blendshapeData = calculateBlendshapes(userId, result);
            if (blendshapeData) {
              updateBlendshape(userId, blendshapeData);
              ws.sendMotion(userId, blendshapeData);
            }
          }
          requestAnimationFrame(detect);
        };
        detect();
      };

      const animate = () => {
        requestAnimationFrame(animate);
        updateAvatars(clock.getDelta());
        renderer.render(scene, camera);
      };

      nameInput.addEventListener("input", (e) => {
        const newName = e.target.value.trim();
        localStorage.setItem("userName", newName);
        updateAvatarName(userId, newName);
        sendName(userId, newName); // WebSocketで送信
      });

      // ドラッグ＆ドロップ対応
      document.addEventListener("dragover", (e) => e.preventDefault());
      document.addEventListener("drop", async (e) => {
        e.preventDefault();
        const file = e.dataTransfer.files[0];
        if (!file.name.endsWith(".vrm")) {
          alert("VRMファイルをドロップしてください");
          return;
        }

        const arrayBuffer = await file.arrayBuffer();
        ws.sendVrm(userId, arrayBuffer);
        await changeAvatar(userId, arrayBuffer);
      });

      window.addEventListener("resize", () => resize());

      const backgroundColors = [
        0x00ff00, 0x00ffff, 0x0000ff, 0xff00ff, 0xff0000, 0xffff00,
      ];

      let backgroundColorIndex =
        localStorage.getItem("backgroundColorIndex") || 0;

      setBackgroundColor(backgroundColors[backgroundColorIndex]);

      // Ctrl+左右矢印で背景色変更
      window.addEventListener("keydown", async (event) => {
        // Windows/Linux: Ctrlキー, Mac: Metaキー(Commandキー) どちらかが押されていればOK
        if (!(event.ctrlKey || event.metaKey)) return;
        if (event.key === "ArrowRight") {
          backgroundColorIndex =
            backgroundColorIndex === backgroundColors.length - 1
              ? 0
              : backgroundColorIndex + 1;
        } else if (event.key === "ArrowLeft") {
          backgroundColorIndex =
            backgroundColorIndex === 0
              ? backgroundColors.length - 1
              : backgroundColorIndex - 1;
        } else {
          return;
        }

        setBackgroundColor(backgroundColors[backgroundColorIndex]);

        localStorage.setItem("backgroundColorIndex", backgroundColorIndex);
      });

      initCamera().then((v) => startFaceTracking(v));
      animate();
    </script>
    <input
      id="name-input"
      type="text"
      placeholder="名前"
      style="position: fixed"
    />
    <video id="video" autoplay playsinline></video>
  </body>
</html>
